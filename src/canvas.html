<html>
    <head>
        <title>Kinect Coordinates</title>

        <style type="text/css">
            html, body { overflow: hidden; background-color:black; }

            #pos_x { position:absolute; left:10%; top: 10%; width:20%; font-size: 3em; font-family: arial; color: white; text-shadow: 0 0 0.3em white; }
            #pos_y { position:absolute; left:10%; top: 25%; width:20%; font-size: 3em; font-family: arial; color: white; text-shadow: 0 0 0.3em white; }
            #pos_z { position:absolute; left:70%; top: 10%; width:20%; font-size: 3em; font-family: arial; color: white; text-shadow: 0 0 0.3em white; }

            #border { position: fixed; width: 790px; height: 590px; padding: 0; margin: 0; top: 0; left: 0; border: solid white 5px; }
        </style>

        <script src="js/jquery-1.8.2.js" type="text/javascript"></script>

    </head>

    <body>
        <canvas id="myCanvas"></canvas>

        <script>

            $(document).ready(function() {
                // Show the border
                Surface_PropertiesChanged();

                // Request the lowest point cube
                Authority.request("KinectLowestPointCube", {
                    relativeto : Surface.Name,          // The surface we want information relative too
                    surface_zoffset : 0.05, // 0.015    // The height from the surface we want to accept points from (in meters)
                    height:0.10,                        // The height from the surface+offset we want to no longer accept points from (in meters)
                    callback : "Handle_LowestPoints",   // The function we want to call back with information
                    point_limit : 50,                   // The max number of points to accept
                    sendemptyframes : false,            // Do we want callbacks when we have empty frames (i.e. when we have no points at all)
                });
            });

            // Fades out border after changing surface properties
            function Surface_PropertiesChanged() {
                $("#border").show().delay(2000).fadeOut(500);
            }

            var c = document.getElementBy("myCanvas");
            var ctx = c.getContext("2d");

            // Number of frames that the hand has been in place
            var iFrameCount = 0;

            // Coordinates of hand in frame, range is [0,1]
            var avg_pos_x = -1;
            var avg_pos_y = -1;
            var avg_pos_z = -1;

            // Pixel coordinate values of hand in frame
            var pixel_x = -1;
            var pixel_y = -1;

            /**
             * @brief Compute the average of a set of points
             * @param pointList the list of (x,y,z) coordinates
             * @param coord the coordinate in pointList to compute the average of, where (x,y,z) maps to (0,1,2)
             * @return the average value of the given coordinate
             */
            function comp_avg(pointList, coord) {
                var cnt = values.length;
                var tot = 0;
                for (var i = 0; i < cnt; i++) {
                    tot += values[i][comp];
                }
                return tot / cnt;
            }

            /**
             * @brief Called by the toolkit with point cloud data
             * This is because we set it up to be called when we go: Authority.request("KinectLowestPointCube", {...args...})
             * @param pointList This is a list of points in the format: [[x,y,z],[x,y,z],[x,y,z]]
             */
            function Handle_LowestPoints(pointList) {
                // If we have more than 40 points, print coordinates
                if (pointList.length > 40) {
                        avg_pos_x = comp_avg(pointList, 0).toPrecision(3);
                        // $("#pos_x").text("x: " + avg_pos_x);
                        avg_pos_y = comp_avg(pointList, 1).toPrecision(3);
                        // $("#pos_y").text("y: " + avg_pos_y);
                        avg_pos_z = comp_avg(pointList, 2).toPrecision(3);
                        // $("#pos_z").text("z: " + avg_pos_z);

                        // Draw a circle on the screen where interaction occurred
                        pixel_x = avg_pos_x * Convert_M2P(Surface.Width);
                        pixel_y = avg_pos_y * Convert_M2P(Surface.Height);
                        drawCircle(pixel_x, pixel_y);
                }
            }

            /**
             * @brief Draws a circle at the given x and y pixel coordinates
             * @param x the x coordinate for the pixel to center the circle on
             * @param y the y coordinate for the pixel to center the circle on
             */
            function drawCircle(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2*Math.PI);
                ctx.stroke();
            }

        </script>

    </body>
</html>
